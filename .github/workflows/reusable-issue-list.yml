name: 📝 Issue List CI (Reusable)

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
        description: "Name of the repository (api, client, infra)"
      issue_prefix:
        required: false
        type: string
        default: "TEM"
        description: "Issue prefix (e.g., TEM, LAY)"
      jira_url:
        required: true
        type: string
        description: "JIRA base URL"
      jira_mail:
        required: true
        type: string
        description: "JIRA email for authentication"
    secrets:
      JIRA_API_TOKEN:
        required: true
        description: "JIRA API token"
      AUTO_DEPLOY_TOKEN:
        required: true
        description: "GitHub token with PR permissions"
      PR_BACK_REMINDER_WEBHOOK_URL:
        required:
        description: "Discord Webhook URL for backend notifications"
      PR_FRONT_REMINDER_WEBHOOK_URL:
        required: true
        description: "Discord Webhook URL for frontend notifications"
      PR_DEVOPS_REMINDER_WEBHOOK_URL:
        required: true
        description: "Discord Webhook URL for devops notifications"

jobs:
  comment-issue-list:
    if: ${{ github.actor != 'dependabot[bot]' && github.actor != 'dependabot-preview[bot]' }}
    runs-on: ubuntu-latest
    name: Comment Issues from commits
    steps:
      - name: Create a list of all tickets found in commits and check for translations
        id: filter-issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
          script: |
            const pull_number = context.issue.number;
            let allCommits = [];
            let page = 0;
            let response = [];

            do {
              page++;
              response = await github.rest.pulls.listCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pull_number,
                per_page: 100,
                page: page
              });
              allCommits = allCommits.concat(response.data);
            } while (response.data.length > 0);

            const issuePrefix = '${{ inputs.issue_prefix }}';
            const regex = new RegExp(issuePrefix + '-\\d+', 'g');

            const commitMessages = allCommits.map(commit => commit.commit.message);
            const relevantMessages = commitMessages
              .filter(message => !message.toLowerCase().includes('merge branch'))
              .filter(message => !message.toLowerCase().includes(':construction:'))
              .filter(message => !message.toLowerCase().includes('🚧'))
              .flatMap(message => Array.from(message.matchAll(regex)))
              .map(match => match[0]);

            const uniqueIssueIDs = [...new Set(relevantMessages)];
            core.setOutput('issue_list', uniqueIssueIDs.join(','));

            // Filter and list commit messages by Dependabot
            const dependabotCommits = allCommits
              .filter(commit => commit.author && commit.author.login && 
                (commit.author.login === 'dependabot[bot]' || commit.author.login === 'dependabot-preview[bot]'))
              .map(commit => commit.commit.message);
            core.setOutput('dependabot_list', dependabotCommits.join(','));

            // Check for commits containing #TRAD
            const tradCommits = commitMessages
              .filter(message => !message.toLowerCase().includes('merge branch'))
              .filter(message => message.includes('#TRAD'));
            core.setOutput('trad_list', tradCommits.join(','));

      - name: Check and create string from issues
        if: steps.filter-issues.outputs.issue_list != ''
        id: format_details
        uses: actions/github-script@v7
        env:
          ISSUES: ${{ steps.filter-issues.outputs.issue_list }}
          DEPENDABOT_COMMITS: ${{ steps.filter-issues.outputs.dependabot_list }}
          TRAD_COMMITS: ${{ steps.filter-issues.outputs.trad_list }}
          JIRA_URL: ${{ inputs.jira_url }}
          JIRA_MAIL: ${{ inputs.jira_mail }}
          JIRA_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Jira
            const jiraUrl = process.env.JIRA_URL;
            const token = process.env.JIRA_TOKEN;
            const auth = Buffer.from(process.env.JIRA_MAIL + ':' + token).toString('base64');
            
            // Commit List
            const issues = process.env.ISSUES.split(',');
            const dependabotCommits = process.env.DEPENDABOT_COMMITS.split(',');
            const tradCommits = process.env.TRAD_COMMITS.split(',');
            
            // Tweaks
            const targetBranch = process.env.GITHUB_BASE_REF;

            // Date formatting options
            const dateOptions = {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric',
              timeZone: 'Europe/Paris'
            };

            const timeOptions = {
              hour: '2-digit',
              minute: '2-digit',
              hour12: false,
              timeZone: 'Europe/Paris'
            };
            
            // Get Paris date and time
            const rawDate = new Date().toLocaleDateString("fr-FR", dateOptions);
            const capitalizedDate = rawDate
              .split(' ')
              .map(part => part.charAt(0).toUpperCase() + part.slice(1))
              .join(' ');
            const parisTime = new Date().toLocaleTimeString("fr-FR", timeOptions).replace(':', 'h');
            
            const formattedDateTime = `# 🗓️ **${capitalizedDate} - ${parisTime}**\n`;

            let markdownList = "";
            let discordList = "";
            let issuesCount = 0;

            for (const issueKey of issues) {
                const url = `${jiraUrl}/rest/api/3/issue/${issueKey}`;
                const response = await fetch(url, {
                  method: 'GET',
                  headers: {
                      'Authorization': `Basic ${auth}`,
                      'Accept': 'application/json',
                      'Content-Type': 'application/json'
                  }
                });

                if (!response.ok) {
                  console.error(`[${issueKey}] Failed to fetch issue details: ${response.statusText}`);
                  continue;
                }
    
                const issueData = await response.json();
                const issueStatusId = issueData.fields.status.id;
                const issueLink = `${jiraUrl}/browse/${issueKey}`;
                const issueName = issueData.fields.summary;

                // Skip completed issues for staging/main based on your JIRA status IDs
                const doneStatusId = "10008";     // Done
                const testingStatusId = "10011";  // Testing  
                const toDeployStatusId = "10013"; // To Deploy

                if (!(issueStatusId === doneStatusId || 
                    (targetBranch === 'staging' && (issueStatusId === testingStatusId || issueStatusId === toDeployStatusId)))) {
                    markdownList += `- [${issueKey}](${issueLink}) - ${issueName}\n`;
                    discordList += `• [${issueKey}](${issueLink}) - ${issueName}\n`;
                    issuesCount += 1;
                }
            }

            markdownList = `${formattedDateTime}## 🎟️ **${issuesCount}** Issues\n${markdownList}`;

            if (dependabotCommits.length > 0 && dependabotCommits[0] !== "") {
              let dependabotList = `## 🤖 ${dependabotCommits.length} Dependabot's AutoPR\n`;
              for (const commit of dependabotCommits) {
                const commitMessage = commit.split('\n')[2];
                dependabotList += `- ${commitMessage}\n`;
              }
              markdownList += dependabotList;
            }

            // Add translations section
            if (tradCommits.length > 0 && tradCommits[0] !== "") {
              let translationList = `## 🌍 Nouvelle Traduction(s)\n`;
              let discordTranslationList = `\n🌍 Nouvelle Traduction(s):\n`;

              for (const commit of tradCommits) {
                translationList += `- Nouvelle Traduction - ${commit}\n`;
                discordTranslationList += `• Nouvelle Traduction - ${commit}\n`;
              }

              markdownList += translationList;
              discordList += discordTranslationList;
            }

            // Set outputs
            core.setOutput('formatted_string', markdownList);
            core.setOutput('formatted_discord_string', discordList);
            core.setOutput('count', issuesCount);

      - name: Update PR body
        if: steps.format_details.outputs.count > 0
        uses: actions/github-script@v7
        with:
            github-token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
            script: |
              const issueBody = `${{ steps.format_details.outputs.formatted_string }}`;
            
              const prNumber = context.payload.pull_request.number;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
        
              await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: prNumber,
                  body: issueBody
              });

      - name: Send Discord Notification
        if: >-
           steps.format_details.outputs.count > 0 &&
           github.event_name == 'pull_request' &&
           github.event.action == 'closed' &&
           github.event.pull_request.merged == true
        run: |
          # Create timestamp
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%S.000Z)
          
          # Repository-specific colors and emojis
          case "${{ inputs.repository_name }}" in
            "api")
              COLOR="3066993"      # Green
              REPO_EMOJI="🔧"
              ;;
            "client")
              COLOR="15844367"     # Gold/Orange  
              REPO_EMOJI="📱"
              ;;
            "infra")
              COLOR="10181046"     # Purple
              REPO_EMOJI="⚙️"
              ;;
            *)
              COLOR="5793266"      # Blue
              REPO_EMOJI="📦"
              ;;
          esac

          # Build Discord payload
          jq -n \
            --arg title "🎟️ Tickets à venir lors du déploiement imminent" \
            --arg description "${{ steps.format_details.outputs.formatted_discord_string }}" \
            --argjson color "${COLOR}" \
            --arg repo_name "${{ inputs.repository_name }}" \
            --arg repo_emoji "${REPO_EMOJI}" \
            --arg count "${{ steps.format_details.outputs.count }}" \
            --arg timestamp "${TIMESTAMP}" \
            '{
              "embeds": [
                {
                  "title": "\($repo_emoji) \($title)",
                  "description": $description,
                  "color": $color,
                  "fields": [
                    {
                      "name": "📦 Repository",
                      "value": $repo_name,
                      "inline": true
                    },
                    {
                      "name": "🎫 Total Issues",
                      "value": $count,
                      "inline": true
                    }
                  ],
                  "timestamp": $timestamp,
                  "footer": {
                    "text": "\($repo_name) • GitHub Actions",
                    "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                  }
                }
              ]
            }' > discord_payload.json
          
          # Send to Discord
          # Send to Discord - use repository-specific webhook
          case "${{ inputs.repository_name }}" in
            "api")
              WEBHOOK_URL="${{ secrets.PR_BACK_REMINDER_WEBHOOK_URL }}"
              ;;
            "client")
              WEBHOOK_URL="${{ secrets.PR_FRONT_REMINDER_WEBHOOK_URL }}"
              ;;
            "infra")
              WEBHOOK_URL="${{ secrets.PR_DEVOPS_REMINDER_WEBHOOK_URL }}"
              ;;
            *)
              WEBHOOK_URL="${{ secrets.PR_BACK_REMINDER_WEBHOOK_URL }}"
              ;;
          esac

          HTTP_RESPONSE=$(curl -s -w "%{http_code}" \
                              -H "Content-Type: application/json" \
                              -d @discord_payload.json \
                              "${WEBHOOK_URL}")
          
          HTTP_CODE=${HTTP_RESPONSE: -3}
          
          if [[ $HTTP_CODE -ge 200 && $HTTP_CODE -lt 300 ]]; then
            echo "✅ Discord notification sent successfully! (HTTP $HTTP_CODE)"
          else
            echo "❌ Failed to send Discord notification. HTTP Code: $HTTP_CODE"
            echo "Response: ${HTTP_RESPONSE%???}"
          fi