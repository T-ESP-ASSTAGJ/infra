# .github/workflows/pr-creation.yml
name: 🚀 PR Creation on Merge

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
        description: "Name of the repository (api, client, etc.)"
    secrets:
      AUTO_DEPLOY_TOKEN:
        required: true
        description: "GitHub token with push/PR permissions"

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
          fetch-depth: 0
          ref: staging  # Ensure we're on staging branch

      - name: Fetch all branches
        run: |
          git fetch --all
          git branch -r

      - name: Create Next Stage PR
        env:
          GH_TOKEN: ${{ secrets.AUTO_DEPLOY_TOKEN }}
        run: |
          CURRENT_BRANCH=${GITHUB_REF#refs/heads/}
          echo "🔍 Processing merge to: $CURRENT_BRANCH"
          
          # Get the most recent merge commit
          MERGE_COMMIT=$(git log -1 --merges --format="%H %s")
          MERGE_MSG=$(git log -1 --merges --format="%s")
          
          echo "📝 Recent merge: $MERGE_MSG"
          
          # Extract source branch from GitHub merge format
          SOURCE_BRANCH=""
          if [[ "$MERGE_MSG" =~ from[[:space:]]+([^[:space:]]+) ]]; then
            SOURCE_BRANCH="${BASH_REMATCH[1]}"
          fi
          
          echo "📊 Source branch: $SOURCE_BRANCH"
          
          case "$CURRENT_BRANCH" in
            TEM-*)
              # When pushing to TEM branch, create PR from TEM branch to staging
              echo "🎯 Creating TEM → staging PR for: $CURRENT_BRANCH"
          
              # Check if PR already exists
              if ! gh pr list --base staging --head "$CURRENT_BRANCH" --json number | jq -e '.[] | select(.number)' > /dev/null 2>&1; then
          
                # Get commit message for PR context
                COMMIT_MSG=$(git log -1 --format="%s")
                echo "💬 Latest commit: $COMMIT_MSG"
          
                # Determine PR type based on gitmoji
                PR_TITLE="$COMMIT_MSG"
          
                if [[ "$COMMIT_MSG" =~ (🚑|:ambulance:) ]]; then
                  PR_TITLE="🚑 HOTFIX: $COMMIT_MSG"
          
                  PR_BODY="## 🚨 CRITICAL HOTFIX
          
          **Ticket**: $CURRENT_BRANCH  
          **Priority**: Critical - Requires immediate review
          
          ### 🔥 Issue:
          This is a critical hotfix that needs urgent attention and deployment.
          
          ### 💬 Latest Commit:
          \`$COMMIT_MSG\`
          
          ---
          🤖 *Auto-created from critical commit in ${{ inputs.repository_name }}*"
          
                elif [[ "$COMMIT_MSG" =~ (✨|:sparkles:|🐛|:bug:|🚀|:rocket:|♻️|:recycle:|🎨|:art:|💄|:lipstick:|⚡|:zap:|🔧|:wrench:) ]]; then
          
                  PR_BODY="## 🚀 Feature Ready for Review
          
          **Ticket**: $CURRENT_BRANCH  
          
          ### 💬 Latest Commit:
          \`$COMMIT_MSG\`
          
          ---
          🤖 *Auto-created from gitmoji commit in ${{ inputs.repository_name }}*"
          
                else
                  # Generic PR for commits without recognized gitmoji
                  PR_BODY="## 📝 Code Changes Ready
          
          **Ticket**: $CURRENT_BRANCH
          
          ### 💬 Latest Commit:
          \`$COMMIT_MSG\`
          
          ---
          🤖 *Auto-created from commit in ${{ inputs.repository_name }}*"
                fi
          
                # Create the PR without labels
                gh pr create \
                  --title "$PR_TITLE" \
                  --body "$PR_BODY" \
                  --base staging \
                  --head "$CURRENT_BRANCH"
          
                echo "✅ PR created: $CURRENT_BRANCH → staging"
          
                # Log PR creation
                mkdir -p .github/deployment-history
                echo "$(date -Iseconds) | PR_CREATED | $CURRENT_BRANCH→staging | $COMMIT_MSG" >> .github/deployment-history/$(date +%Y-%m).log
          
              else
                echo "ℹ️ PR already exists: $CURRENT_BRANCH → staging"
              fi
              ;;
          
            staging)
              # When something merges to staging, create PR from staging to main
              echo "🎭 Creating staging → main PR"
          
              # Determine main branch name and ensure it exists
              echo "🔍 Checking for main branches..."
              git branch -r | grep -E "(origin/main|origin/master)"
          
              MAIN_BRANCH="main"
              if git ls-remote --heads origin | grep -q "refs/heads/master"; then
                if ! git ls-remote --heads origin | grep -q "refs/heads/main"; then
                  MAIN_BRANCH="master"
                fi
              fi
          
              echo "🎯 Using main branch: $MAIN_BRANCH"
          
              # Ensure local tracking branch exists
              if ! git show-ref --verify --quiet refs/heads/$MAIN_BRANCH; then
                git checkout -b $MAIN_BRANCH origin/$MAIN_BRANCH
              fi
          
              # Switch back to staging
              git checkout staging
          
              # Check if PR already exists
              if ! gh pr list --base "$MAIN_BRANCH" --head staging --json number | jq -e '.[] | select(.number)' > /dev/null 2>&1; then
          
                # Get all TEM tickets that are in staging but not yet in main
                STAGING_TICKETS=$(git log staging --not "$MAIN_BRANCH" --oneline --merges | grep -oE 'from TEM-[0-9]+' | sed 's/from //' | sort | uniq | head -10)
          
                if [[ -n "$STAGING_TICKETS" ]]; then
                  TICKET_LIST=$(echo "$STAGING_TICKETS" | tr '\n' ' ')
                  PR_TITLE="🚀 Deploy to Production: $(echo $STAGING_TICKETS | wc -w) tickets ready"
          
                  PR_BODY="## 🚀 Production Deployment
          
          **Ready for Production:** $(echo $STAGING_TICKETS | wc -w) tickets tested and approved on staging
          
          ### 🎫 Tickets Included:
          $(echo "$STAGING_TICKETS" | sed 's/^/- /')
          
          ### 📋 Deployment Checklist:
          - [ ] All tickets tested on staging
          - [ ] Database migrations reviewed
          - [ ] Monitoring alerts configured
          - [ ] Rollback plan confirmed
          
          ### 🔄 Source:
          - **From**: staging
          - **Latest merge**: $SOURCE_BRANCH
          - **Repository**: ${{ inputs.repository_name }}
          
          ---
          🤖 *Auto-created when $SOURCE_BRANCH was merged to staging*"
          
                  gh pr create \
                    --title "$PR_TITLE" \
                    --body "$PR_BODY" \
                    --base "$MAIN_BRANCH" \
                    --head staging
          
                  echo "✅ Production deployment PR created"
          
                  # Create deployment history entry
                  mkdir -p .github/deployment-history
                  echo "$(date -Iseconds) | staging→$MAIN_BRANCH | $TICKET_LIST | $SOURCE_BRANCH" >> .github/deployment-history/$(date +%Y-%m).log
          
                else
                  echo "ℹ️ No new tickets found for production deployment"
                fi
              else
                echo "ℹ️ staging → $MAIN_BRANCH PR already exists - skipping creation"
              fi
              ;;
          
            main|master)
              # When something merges to main, log the deployment
              echo "🎯 Production deployment completed"
          
              # Determine which branch we're on
              MAIN_BRANCH="$CURRENT_BRANCH"
          
              # Extract tickets that were just deployed
              DEPLOYED_TICKETS=$(git log -1 --merges --format="%s" | grep -oE 'TEM-[0-9]+' | sort | uniq)
          
              if [[ -z "$DEPLOYED_TICKETS" ]]; then
                # Fallback: look at staging commits that are now in main
                DEPLOYED_TICKETS=$(git log "$MAIN_BRANCH" --not "$MAIN_BRANCH"~1 --oneline --merges | grep -oE 'from TEM-[0-9]+' | sed 's/from //' | sort | uniq)
              fi
          
              if [[ -n "$DEPLOYED_TICKETS" ]]; then
                TICKET_LIST=$(echo "$DEPLOYED_TICKETS" | tr '\n' ' ')
          
                # Log successful deployment
                mkdir -p .github/deployment-history
                echo "$(date -Iseconds) | DEPLOYED | $TICKET_LIST | $MAIN_BRANCH | SUCCESS" >> .github/deployment-history/$(date +%Y-%m).log
          
                echo "📊 Deployed tickets: $TICKET_LIST"
          
                # Create deployment summary
                cat << EOF > deployment-summary.md
          # 🎉 Production Deployment Complete
          
          **Date**: $(date -Iseconds)
          **Tickets Deployed**: $(echo $DEPLOYED_TICKETS | wc -w)
          
          ## 🎫 Deployed Tickets:
          $(echo "$DEPLOYED_TICKETS" | sed 's/^/- /')
          
          ## 📈 Deployment Stats:
          - Repository: ${{ inputs.repository_name }}
          - Branch: $CURRENT_BRANCH
          - Commit: ${GITHUB_SHA:0:8}
          
          ---
          🤖 *Auto-generated deployment summary*
          EOF
          
                echo "✅ Deployment logged and summary created"
              fi
              ;;
          esac