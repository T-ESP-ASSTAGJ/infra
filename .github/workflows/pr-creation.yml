name: ðŸš€ PR Creation on Merge

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
        description: "Name of the repository (api, client, etc.)"
    secrets:
      AUTO_DEPLOY_TOKEN:
        required: true
        description: "GitHub token with push/PR permissions"

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.AUTO_DEPLOY_TOKEN }}
          fetch-depth: 0

      - name: Create Next Stage PR
        env:
          GH_TOKEN: ${{ secrets.AUTO_DEPLOY_TOKEN }}
        run: |
          CURRENT_BRANCH=${GITHUB_REF#refs/heads/}
          echo "ðŸ” Processing merge to: $CURRENT_BRANCH"
          
          # Get the most recent merge commit
          MERGE_COMMIT=$(git log -1 --merges --format="%H %s")
          MERGE_MSG=$(git log -1 --merges --format="%s")
          
          echo "ðŸ“ Recent merge: $MERGE_MSG"
          
          # Extract source branch from GitHub merge format
          SOURCE_BRANCH=""
          if [[ "$MERGE_MSG" =~ from[[:space:]]+([^[:space:]]+) ]]; then
            SOURCE_BRANCH="${BASH_REMATCH[1]}"
          fi
          
          echo "ðŸ“Š Source branch: $SOURCE_BRANCH"
          
          case "$CURRENT_BRANCH" in
            TEM-*)
              # When pushing to TEM branch, create PR from TEM branch to staging
              echo "ðŸŽ¯ Creating TEM â†’ staging PR for: $CURRENT_BRANCH"
          
              # Check if PR already exists
              if ! gh pr list --base staging --head "$CURRENT_BRANCH" --json number | jq -e '.[] | select(.number)' > /dev/null 2>&1; then
          
                # Get commit message for PR context
                COMMIT_MSG=$(git log -1 --format="%s")
                echo "ðŸ’¬ Latest commit: $COMMIT_MSG"
          
                # Determine PR type based on gitmoji
                PR_TITLE="$COMMIT_MSG"
          
                if [[ "$COMMIT_MSG" =~ (ðŸš‘|:ambulance:) ]]; then
                  PR_TITLE="ðŸš‘ HOTFIX: $COMMIT_MSG"
          
                  PR_BODY="## ðŸš¨ CRITICAL HOTFIX
          
          **Ticket**: $CURRENT_BRANCH  
          **Priority**: Critical - Requires immediate review
          
          ### ðŸ”¥ Issue:
          This is a critical hotfix that needs urgent attention and deployment.
          
          ### ðŸ’¬ Latest Commit:
          \`$COMMIT_MSG\`
          
          ### ðŸ“‹ Review Checklist:
          - [ ] Hotfix addresses the critical issue
          - [ ] No regression introduced  
          - [ ] Ready for immediate staging deployment
          - [ ] Production deployment plan confirmed
          
          ### ðŸ”„ Next Steps:
          1. Review and approve immediately
          2. Merge to staging for validation
          3. Create production deployment PR
          
          ---
          ðŸ¤– *Auto-created from critical commit in ${{ inputs.repository_name }}*"
          
                elif [[ "$COMMIT_MSG" =~ (âœ¨|:sparkles:|ðŸ›|:bug:|ðŸš€|:rocket:|â™»ï¸|:recycle:|ðŸŽ¨|:art:|ðŸ’„|:lipstick:|âš¡|:zap:|ðŸ”§|:wrench:) ]]; then
          
                  PR_BODY="## ðŸš€ Feature Ready for Review
          
          **Ticket**: $CURRENT_BRANCH  
          
          ### ðŸ’¬ Latest Commit:
          \`$COMMIT_MSG\`
          
          ### ðŸ“‹ Review Checklist:
          - [ ] Code review completed
          - [ ] Tests passing
          - [ ] Documentation updated (if needed)
          - [ ] Ready for staging deployment
          
          ### ðŸ”„ Next Steps:
          1. Review and approve
          2. Merge to staging for QA testing
          3. Deploy to production when ready
          
          ---
          ðŸ¤– *Auto-created from gitmoji commit in ${{ inputs.repository_name }}*"
          
                else
                  # Generic PR for commits without recognized gitmoji
                  PR_BODY="## ðŸ“ Code Changes Ready
          
          **Ticket**: $CURRENT_BRANCH
          
          ### ðŸ’¬ Latest Commit:
          \`$COMMIT_MSG\`
          
          ### ðŸ“‹ Review Checklist:
          - [ ] Code review completed
          - [ ] Changes tested
          - [ ] Ready for staging
          
          ---
          ðŸ¤– *Auto-created from commit in ${{ inputs.repository_name }}*"
                fi
          
                # Create the PR without labels
                gh pr create \
                  --title "$PR_TITLE" \
                  --body "$PR_BODY" \
                  --base staging \
                  --head "$CURRENT_BRANCH"
          
                echo "âœ… PR created: $CURRENT_BRANCH â†’ staging"
          
                # Log PR creation
                mkdir -p .github/deployment-history
                echo "$(date -Iseconds) | PR_CREATED | $CURRENT_BRANCHâ†’staging | $COMMIT_MSG" >> .github/deployment-history/$(date +%Y-%m).log
          
              else
                echo "â„¹ï¸ PR already exists: $CURRENT_BRANCH â†’ staging"
              fi
              ;;
          
            staging)
              # When something merges to staging, create PR from staging to main
              echo "ðŸŽ­ Creating staging â†’ main PR"
          
              # Check if PR already exists
              if ! gh pr list --base main --head staging --json number | jq -e '.[] | select(.number)' > /dev/null 2>&1; then
          
                # Get all TEM tickets that are in staging but not yet in main
                STAGING_TICKETS=$(git log staging --not main --oneline --merges | grep -oE 'from TEM-[0-9]+' | sed 's/from //' | sort | uniq | head -10)
          
                if [[ -n "$STAGING_TICKETS" ]]; then
                  TICKET_LIST=$(echo "$STAGING_TICKETS" | tr '\n' ' ')
                  PR_TITLE="ðŸš€ Deploy to Production: $(echo $STAGING_TICKETS | wc -w) tickets ready"
          
                  PR_BODY="## ðŸš€ Production Deployment
          
          **Ready for Production:** $(echo $STAGING_TICKETS | wc -w) tickets tested and approved on staging
          
          ### ðŸŽ« Tickets Included:
          $(echo "$STAGING_TICKETS" | sed 's/^/- /')
          
          ### ðŸ“‹ Deployment Checklist:
          - [ ] All tickets tested on staging
          - [ ] Database migrations reviewed
          - [ ] Monitoring alerts configured
          - [ ] Rollback plan confirmed
          
          ### ðŸ”„ Source:
          - **From**: staging
          - **Latest merge**: $SOURCE_BRANCH
          - **Repository**: ${{ inputs.repository_name }}
          
          ---
          ðŸ¤– *Auto-created when $SOURCE_BRANCH was merged to staging*"
          
                  gh pr create \
                    --title "$PR_TITLE" \
                    --body "$PR_BODY" \
                    --base main \
                    --head staging
          
                  echo "âœ… Production deployment PR created"
          
                  # Create deployment history entry
                  mkdir -p .github/deployment-history
                  echo "$(date -Iseconds) | stagingâ†’main | $TICKET_LIST | $SOURCE_BRANCH" >> .github/deployment-history/$(date +%Y-%m).log
          
                else
                  echo "â„¹ï¸ No new tickets found for production deployment"
                fi
              else
                echo "â„¹ï¸ staging â†’ main PR already exists"
              fi
              ;;
          
            main|master)
              # When something merges to main, log the deployment
              echo "ðŸŽ¯ Production deployment completed"
          
              # Extract tickets that were just deployed
              DEPLOYED_TICKETS=$(git log -1 --merges --format="%s" | grep -oE 'TEM-[0-9]+' | sort | uniq)
          
              if [[ -z "$DEPLOYED_TICKETS" ]]; then
                # Fallback: look at staging commits that are now in main
                DEPLOYED_TICKETS=$(git log main --not main~1 --oneline --merges | grep -oE 'from TEM-[0-9]+' | sed 's/from //' | sort | uniq)
              fi
          
              if [[ -n "$DEPLOYED_TICKETS" ]]; then
                TICKET_LIST=$(echo "$DEPLOYED_TICKETS" | tr '\n' ' ')
          
                # Log successful deployment
                mkdir -p .github/deployment-history
                echo "$(date -Iseconds) | DEPLOYED | $TICKET_LIST | main | SUCCESS" >> .github/deployment-history/$(date +%Y-%m).log
          
                echo "ðŸ“Š Deployed tickets: $TICKET_LIST"
          
                # Create deployment summary
                cat << EOF > deployment-summary.md
          # ðŸŽ‰ Production Deployment Complete
          
          **Date**: $(date -Iseconds)
          **Tickets Deployed**: $(echo $DEPLOYED_TICKETS | wc -w)
          
          ## ðŸŽ« Deployed Tickets:
          $(echo "$DEPLOYED_TICKETS" | sed 's/^/- /')
          
          ## ðŸ“ˆ Deployment Stats:
          - Repository: ${{ inputs.repository_name }}
          - Branch: $CURRENT_BRANCH
          - Commit: ${GITHUB_SHA:0:8}
          
          ---
          ðŸ¤– *Auto-generated deployment summary*
          EOF
          
                echo "âœ… Deployment logged and summary created"
              fi
              ;;
          esac